{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar isNil_1 = __importDefault(require(\"lodash/isNil\"));\n\nvar invoke_1 = __importDefault(require(\"lodash/invoke\"));\n\nvar moment_1 = __importDefault(require(\"moment\"));\n\nvar PropTypes = __importStar(require(\"prop-types\"));\n\nvar React = __importStar(require(\"react\"));\n\nvar DayPicker_1 = __importDefault(require(\"../pickers/dayPicker/DayPicker\"));\n\nvar MonthPicker_1 = __importDefault(require(\"../pickers/monthPicker/MonthPicker\"));\n\nvar HourPicker_1 = __importDefault(require(\"../pickers/timePicker/HourPicker\"));\n\nvar MinutePicker_1 = __importDefault(require(\"../pickers/timePicker/MinutePicker\"));\n\nvar YearPicker_1 = __importDefault(require(\"../pickers/YearPicker\"));\n\nvar InputView_1 = __importDefault(require(\"../views/InputView\"));\n\nvar BaseInput_1 = __importStar(require(\"./BaseInput\"));\n\nvar lib_1 = require(\"../lib\");\n\nvar parse_1 = require(\"./parse\");\n\nvar shared_1 = require(\"./shared\");\n\nvar nextMode = {\n  year: 'month',\n  month: 'day',\n  day: 'hour',\n  hour: 'minute',\n  minute: 'year'\n};\n\nfunction getNextMode(currentMode) {\n  return nextMode[currentMode];\n}\n\nvar prevMode = {\n  minute: 'hour',\n  hour: 'day',\n  day: 'month',\n  month: 'year',\n  year: 'minute'\n};\n\nfunction getPrevMode(currentMode) {\n  return prevMode[currentMode];\n}\n\nvar DateTimeInput =\n/** @class */\nfunction (_super) {\n  __extends(DateTimeInput, _super);\n\n  function DateTimeInput(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.componentDidUpdate = function (prevProps) {\n      // update internal date if ``value`` prop changed and successuffly parsed\n      if (prevProps.value !== _this.props.value) {\n        var parsed = parse_1.parseValue(_this.props.value, _this.getDateTimeFormat(), _this.props.localization);\n\n        if (parsed) {\n          _this.setState({\n            year: parsed.year(),\n            month: parsed.month(),\n            date: parsed.date(),\n            hour: parsed.hour(),\n            minute: parsed.minute()\n          });\n        }\n      }\n    };\n\n    _this.switchToNextModeUndelayed = function () {\n      _this.setState(function (_a) {\n        var mode = _a.mode;\n        return {\n          mode: getNextMode(mode)\n        };\n      }, _this.onModeSwitch);\n    };\n\n    _this.switchToNextMode = function () {\n      lib_1.tick(_this.switchToNextModeUndelayed);\n    };\n\n    _this.switchToPrevModeUndelayed = function () {\n      _this.setState(function (_a) {\n        var mode = _a.mode;\n        return {\n          mode: getPrevMode(mode)\n        };\n      }, _this.onModeSwitch);\n    };\n\n    _this.switchToPrevMode = function () {\n      lib_1.tick(_this.switchToPrevModeUndelayed);\n    };\n\n    _this.handleSelect = function (e, _a) {\n      var value = _a.value;\n      lib_1.tick(_this.handleSelectUndelayed, e, {\n        value: value\n      });\n    };\n\n    _this.onFocus = function () {\n      if (!_this.props.preserveViewMode) {\n        _this.setState({\n          mode: _this.props.startMode\n        });\n      }\n    };\n\n    _this.handleSelectUndelayed = function (e, _a) {\n      var value = _a.value;\n      var _b = _this.props,\n          closable = _b.closable,\n          disableMinute = _b.disableMinute;\n      var closeCondA = closable && _this.state.mode === 'minute';\n      var closeCondB = closable && disableMinute && _this.state.mode === 'hour';\n\n      if (closeCondA || closeCondB) {\n        _this.closePopup();\n      }\n\n      var endAtMode = disableMinute ? 'hour' : 'minute';\n\n      _this.setState(function (prevState) {\n        var mode = prevState.mode;\n\n        if (mode === endAtMode) {\n          var outValue = moment_1.default(value).format(_this.getDateTimeFormat());\n          invoke_1.default(_this.props, 'onChange', e, __assign({}, _this.props, {\n            value: outValue\n          }));\n        }\n\n        return {\n          year: value.year,\n          month: value.month,\n          date: value.date,\n          hour: value.hour,\n          minute: value.minute\n        };\n      }, function () {\n        return _this.state.mode !== endAtMode && _this.switchToNextMode();\n      });\n    };\n    /** Keeps internal state in sync with input field value. */\n\n\n    _this.onInputValueChange = function (e, _a) {\n      var value = _a.value;\n      var parsedValue = moment_1.default(value, _this.getDateTimeFormat());\n\n      if (parsedValue.isValid()) {\n        _this.setState({\n          year: parsedValue.year(),\n          month: parsedValue.month(),\n          date: parsedValue.date(),\n          hour: parsedValue.hour(),\n          minute: parsedValue.minute()\n        });\n      }\n\n      invoke_1.default(_this.props, 'onChange', e, __assign({}, _this.props, {\n        value: value\n      }));\n    };\n\n    var parsedValue = parse_1.parseValue(props.value, _this.getDateTimeFormat(), props.localization);\n    _this.state = {\n      mode: props.startMode,\n      year: parsedValue ? parsedValue.year() : undefined,\n      month: parsedValue ? parsedValue.month() : undefined,\n      date: parsedValue ? parsedValue.date() : undefined,\n      hour: parsedValue ? parsedValue.hour() : undefined,\n      minute: parsedValue ? parsedValue.minute() : undefined,\n      popupIsClosed: true\n    };\n    return _this;\n  }\n\n  DateTimeInput.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        value = _a.value,\n        dateTimeFormat = _a.dateTimeFormat,\n        dateFormat = _a.dateFormat,\n        timeFormat = _a.timeFormat,\n        initialDate = _a.initialDate,\n        disable = _a.disable,\n        maxDate = _a.maxDate,\n        minDate = _a.minDate,\n        preserveViewMode = _a.preserveViewMode,\n        startMode = _a.startMode,\n        divider = _a.divider,\n        closable = _a.closable,\n        markColor = _a.markColor,\n        marked = _a.marked,\n        localization = _a.localization,\n        onChange = _a.onChange,\n        disableMinute = _a.disableMinute,\n        rest = __rest(_a, [\"value\", \"dateTimeFormat\", \"dateFormat\", \"timeFormat\", \"initialDate\", \"disable\", \"maxDate\", \"minDate\", \"preserveViewMode\", \"startMode\", \"divider\", \"closable\", \"markColor\", \"marked\", \"localization\", \"onChange\", \"disableMinute\"]);\n\n    return React.createElement(InputView_1.default, __assign({\n      popupIsClosed: this.state.popupIsClosed,\n      closePopup: this.closePopup,\n      openPopup: this.openPopup,\n      onFocus: this.onFocus,\n      onMount: this.onInputViewMount,\n      onChange: this.onInputValueChange\n    }, rest, {\n      value: parse_1.dateValueToString(value, dateFormat, localization),\n      renderPicker: function renderPicker() {\n        return _this.getPicker();\n      }\n    }));\n  };\n\n  DateTimeInput.prototype.parseInternalValue = function () {\n    /*\n      Creates moment instance from values stored in component's state\n      (year, month, date, hour, minute) in order to pass this moment instance to\n      underlying picker.\n      Return undefined if none of these state fields has value.\n    */\n    var _a = this.state,\n        year = _a.year,\n        month = _a.month,\n        date = _a.date,\n        hour = _a.hour,\n        minute = _a.minute;\n\n    if (!isNil_1.default(year) || !isNil_1.default(month) || !isNil_1.default(date) || !isNil_1.default(hour) || !isNil_1.default(minute)) {\n      return moment_1.default({\n        year: year,\n        month: month,\n        date: date,\n        hour: hour,\n        minute: minute\n      });\n    }\n  };\n\n  DateTimeInput.prototype.getDateTimeFormat = function () {\n    var _a = this.props,\n        dateFormat = _a.dateFormat,\n        divider = _a.divider,\n        timeFormat = _a.timeFormat,\n        dateTimeFormat = _a.dateTimeFormat;\n    return dateTimeFormat || \"\" + dateFormat + divider + parse_1.TIME_FORMAT[timeFormat];\n  };\n\n  DateTimeInput.prototype.getPicker = function () {\n    var _a = this.props,\n        value = _a.value,\n        initialDate = _a.initialDate,\n        dateFormat = _a.dateFormat,\n        disable = _a.disable,\n        minDate = _a.minDate,\n        maxDate = _a.maxDate,\n        inline = _a.inline,\n        marked = _a.marked,\n        markColor = _a.markColor,\n        localization = _a.localization,\n        tabIndex = _a.tabIndex,\n        pickerStyle = _a.pickerStyle,\n        pickerWidth = _a.pickerWidth;\n    var dateTimeFormat = this.getDateTimeFormat();\n    var pickerProps = {\n      tabIndex: tabIndex,\n      isPickerInFocus: this.isPickerInFocus,\n      isTriggerInFocus: this.isTriggerInFocus,\n      inline: inline,\n      pickerWidth: pickerWidth,\n      pickerStyle: pickerStyle,\n      onCalendarViewMount: this.onCalendarViewMount,\n      closePopup: this.closePopup,\n      onChange: this.handleSelect,\n      onHeaderClick: this.switchToPrevMode,\n      initializeWith: parse_1.buildValue(this.parseInternalValue(), initialDate, localization, dateTimeFormat),\n      value: parse_1.buildValue(value, null, localization, dateTimeFormat, null),\n      minDate: parse_1.parseValue(minDate, dateTimeFormat, localization),\n      maxDate: parse_1.parseValue(maxDate, dateTimeFormat, localization),\n      localization: localization\n    };\n    var disableParsed = parse_1.parseArrayOrValue(disable, dateTimeFormat, localization);\n    var mode = this.state.mode;\n    var markedParsed = parse_1.parseArrayOrValue(marked, dateTimeFormat, localization);\n\n    if (mode === 'year') {\n      return React.createElement(YearPicker_1.default, __assign({}, pickerProps, {\n        disable: shared_1.getDisabledYears(disableParsed)\n      }));\n    }\n\n    if (mode === 'month') {\n      return React.createElement(MonthPicker_1.default, __assign({}, pickerProps, {\n        hasHeader: true,\n        disable: shared_1.getDisabledMonths(disableParsed)\n      }));\n    }\n\n    if (mode === 'day') {\n      return React.createElement(DayPicker_1.default, __assign({}, pickerProps, {\n        marked: markedParsed,\n        markColor: markColor,\n        disable: disableParsed\n      }));\n    }\n\n    if (mode === 'hour') {\n      return React.createElement(HourPicker_1.default, __assign({\n        timeFormat: this.props.timeFormat,\n        hasHeader: true\n      }, pickerProps, {\n        disable: disableParsed\n      }));\n    }\n\n    return React.createElement(MinutePicker_1.default, __assign({\n      timeFormat: this.props.timeFormat,\n      hasHeader: true\n    }, pickerProps, {\n      disable: disableParsed\n    }));\n  };\n  /**\n   * Component responsibility:\n   *  - parse input value\n   *  - handle underlying picker change\n   */\n\n\n  DateTimeInput.defaultProps = __assign({}, BaseInput_1.default.defaultProps, {\n    dateFormat: 'DD-MM-YYYY',\n    timeFormat: '24',\n    startMode: 'day',\n    divider: ' ',\n    icon: 'calendar',\n    preserveViewMode: true,\n    disableMinute: false\n  });\n  DateTimeInput.propTypes = __assign({}, BaseInput_1.BaseInputPropTypes, BaseInput_1.DateRelatedPropTypes, BaseInput_1.TimeRelatedPropTypes, BaseInput_1.MultimodePropTypes, BaseInput_1.DisableValuesPropTypes, BaseInput_1.MarkedValuesPropTypes, BaseInput_1.MinMaxValuePropTypes, {\n    startMode: PropTypes.oneOf(['year', 'month', 'day']),\n\n    /** Date and time divider. */\n    divider: PropTypes.string,\n\n    /** Datetime formatting string. */\n    dateTimeFormat: PropTypes.string\n  });\n  return DateTimeInput;\n}(BaseInput_1.default);\n\nexports.default = DateTimeInput;","map":null,"metadata":{},"sourceType":"script"}